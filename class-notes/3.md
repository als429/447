# Lecture 3 - Programs, Instruction, Registers

## Important to remember
* 8 bits = 1 byte
* a byte  = 2 hex digits
* loads copy from memory to registers
* stores copy from registers to memory

## Basic definitions
* an instruction is a single operation (i.e., step) for the computer to do
* a program is a series of these tiny instructions
* machine language instructions are the pattersn of bits that a processor reads to know what to do 
* assembly language is a human-readable, textual representation 
  * encoded as a 32 bit 
  
## Compilers
* convert source code into object files
 * object files - contain files
 * shove the object file to a linker, which makes the executable
* executbable = what is it, how big is it, what types of features does it use and require

## Virutal Machines
* Split the compiler and linker, and add an extra step
* Intermediate language code = microsoft's name
* virtual machine finishes the job, takes the intermediate code and makes it into machine code
 * usually with a JIT (just-in-time compiler)
* same basic concept as a compile, plus an extra layer

# How a CPU runs a program?
## Abstract answer:
1. read an instruction
2. does what it says
3. go to step 1

* top to bottom
* the CPU can only do stuff from memory
* control unit = the brains of the processer
 * reads instructions
 * carry outs steps, delegates
* registers are like hands, like very small memory within the CPU

![how CPU runs a program](how-cpu-runs-a-program.png)

# ISA
* Instruction set architecture: the interface that a CPU presents to the programmer
 * what it defines
  * What the CPU should be expecting 
  * what patterns of bits mean what things
  * Defines what the CPU can do (add, subtract, call, etc.)
  * What registers it has
  * the machine language 
 * it does not define:
  * How to design the hardware (if any hardware at all, like the Java VM) 
 * you can run programs written in 1978 on a brand new CPU (fun fact), backwards compatibility x1,000
 * ISA example: x86 
  * Any CPU or program from 1978+
 * Kinds of ISAs (2 classes):
  * CISC: Complex Instruction Set Computer (here because of x86)
   * ISA designed for humans to write asm
   * lots of instructions and ways to use them
   * complex instructions
   * x86 is *very* CISCy
  * RISC
   * Reducts Instruction set Computer
   * build the CPU hardware
   * make that hardware run fast
   * write compilers that make machine code
   * generate machine to spit out algo code
   * instructions are very simple
   * MIPS is *very* RISCy
* popular ISAs
 * most x86 are laptops, desktops, and servers
 * (phones, Nintendo Switch) = ARMs (Acorn RISC machine)
  * Takes after MIPS
 * everything else = other ISAs
 * despite its limited use, MIPS has been incredibly influential
  * concepts from MIPS are broadly applicable 

# Registers
* 

# Notes
* https://jarrettbillingsley.github.io/teaching/classes/2201/cs0447/
